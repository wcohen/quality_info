# Debuginfo Data Analysis

Live patching has the expectation that program behavior can be changed
via modifying values of variables.  This is depends on being able to
get represenative state information and being able to update the
desired variables. There may be considerable differences in operation
between the original source code and the final code generated by the
compiler due to the compiler analysis and optimizations.

For this work it appears that the boost Interval Container Library
(ICL)
(https://www.boost.org/doc/libs/1_74_0/libs/icl/doc/html/index.html)
will help simplify the implementation of the analysis.

## Liveness

The debuginfo provided in a file indicate where a value for a variable
is located.  However, the debuginfo does not indicate whether the
value is live for that variable.  For observing a program being able
to read the current value is sufficient.  However, for live patching
changing the value needs to have an effect on the program.  If the
value is dead, any changes to it will have no effect on the program's
execution.

### Implementing liveness checking

Dyninst provides libraries that implement liveness analysis and
examining location lists.

Just going to focus on registers and assume that values in memory are "good to go":
Outline of how to implement the analysis:

* for each function
  * get location lists
    * for each location list entry
      * if stored in register
        * add location list entry range in a boost ICL for the the register
  * for each instruction
    * for each register that is dead
      * check to see if there a location list item in that register


## Multiple variables associated with register

It is possible with common subexpression elimination (CSE) that
multiple variables that have same value end up merged into a single
register.  Changing one of the variables would have an unexpected
change on the other.

Outline of how to implement the analysis:

* for each function
  * get location lists
  * for each location list entry
    * if stored in register
      * add location list entry range in a boost ICL for the the register
  * for each register
    * iterate over the ranges
      * if more than one element in set
        * have multiple variables associated with reg


## Multiple locations for a variable

In theory the compiler selects one place to be the place where the
variable lives, so would not expect to see overlapping entries.
However, maybe this is something that the compiler gets wrong and
might be something to check.

* for each function
  * get location lists
  * for each location variabe list entry
    * add location list entry range in a boost ICL for the the register
  * for each variable loc list
    * iterate over the ranges
      * if more than one element in interval set
        * have multiple locations describing variable

## Multiple value for a variable live at same time

Programming model expects code to execute sequentially one line of
code completes execution before the next line of code is started.
However, the compiler may schedule instructions from multiple lines of
code togeter blurring where the one value for a variable is dead and
another value for the same variable is live.




